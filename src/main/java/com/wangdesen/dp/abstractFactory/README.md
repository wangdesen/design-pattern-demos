#AbstractFactory-Pattern-demos

---

#### 抽象工厂模式
> 提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。
抽象工厂又称为kit模式，属于对象创建型模式

#### 角色定义(以海尔和美的两家的冰箱和洗衣机为例)
- AbstractFactory：抽象工厂
- ConcreteFactory：具体工厂（海尔工厂，美的工厂）
- AbstractProduct：抽象产品（冰箱，洗衣机）
- ConcreteProduct：具体产品（海尔冰箱，海尔洗衣机；美的冰箱，美的洗衣机）

#### UML类图
![abstract_factory_uml icon](https://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg)

#### 时序图
![abstract_factory_time icon](https://design-patterns.readthedocs.io/zh_CN/latest/_images/seq_AbatractFactory.jpg)


#### 优点
- 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。
所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。
另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。
- 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。
这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。（比如我只要海尔电器）
- 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。

#### 缺点
- 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品（现有的抽象工厂只能生产冰箱和洗衣机，如果想生产电视机就需要很大的改动）
- 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。

#### 适用环境
- 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。
- 系统中有多于一个的产品族，而每次只使用其中某一产品族。（用户只使用海尔电器家族）
- 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

#### 总结
> 抽象工厂模式包含四个角色：抽象工厂用于声明生成抽象产品的方法；
具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；
抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；
具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。
